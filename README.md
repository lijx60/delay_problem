# delay_problem
discuss delay problem.
  
讨论hal_delay函数问题
hal_delay是初学者应用很广泛的一个函数。一般说来必须遵循以下二点：在中断里面不能使用这类延时，中断函数要快进快出，用的时间越短越好。但一些条件下，中断必须要用延时到怎么办？如少量的延时。很多人就很顺手地把hal_delay用进去。
若进程少，程序简单，中断内还是可以少量延时，尤其是在学习模拟阶段。但不能用hal_delay函数做延时，可以采用主程序一直循环计时方式。因为hal_delay函数是采用中断方法计数的！中断里再调用其它中断函数，既形成中断嵌套，而hal_delay函数中断优先级设置最低，无法抢到执行资源；而中断程序又因定时未到而无法出来，相互等对方造成死锁。所以中断程序不适合调用hal_delay。以上理论是说的，实际应用中没有例证。本程序就模拟上述状况，看看中断函数调用hal_delay延时了，会有什么现象？
此程序中用GPIO中断，当按键压下，既发生沿边中断。此时中断内要处理抖动延时，防止干扰误动，一般20~30ms。若hal_delay延时，若中断发生，真的发生死锁，程序无法运行。但采用cpu主循环计时，既调用delay_ms延时，浪费资源但程序会正常执行。
实验目的没有那么简单。试想，若我们采用优先级反转方式，是不是就可以调用hal_delay函数？事先把GPIO中断优先级设置低点，再将hal_delay函数优先级设置高点（如令TickPriority = 0）。中断嵌套就不会抢占hal_delay资源，看看程序运行会出现什么状况？
结果奇迹出现了：中断函数可以调用hal_delay做延时，不会发生死锁现象。
当然，这只是检验一下优先级问题，加深对hal_delay函数理解。在中断函数内，还是不能调用延时函数的！ 
#define  TICK_INT_PRIORITY            ((uint32_t)15) 
